{
  "version": 3,
  "sources": ["../../escape-string-regexp/index.js", "../../mdast-util-find-and-replace/lib/index.js", "../../mdast-util-gfm-autolink-literal/lib/index.js", "../../mdast-util-gfm-footnote/lib/index.js", "../../mdast-util-gfm-strikethrough/lib/index.js", "../../markdown-table/index.js", "../../mdast-util-gfm-table/lib/index.js", "../../mdast-util-gfm-task-list-item/lib/index.js", "../../mdast-util-gfm/lib/index.js"],
  "sourcesContent": ["export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it‚Äôs always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns‚Äô stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n", "/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) ‚Äî whole match\n *   * `...capture` (`Array<string>`) ‚Äî matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) ‚Äî info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * ‚Ä¶or when `false`, do not replace at all\n *   * ‚Ä¶or when `string`, replace with a text node of that value\n *   * ‚Ä¶or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasn‚Äôt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n", "/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If it‚Äôs an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n", "/**\n * @import {\n *   CompileContext,\n *   Extension as FromMarkdownExtension,\n *   Handle as FromMarkdownHandle\n * } from 'mdast-util-from-markdown'\n * @import {ToMarkdownOptions} from 'mdast-util-gfm-footnote'\n * @import {\n *   Handle as ToMarkdownHandle,\n *   Map,\n *   Options as ToMarkdownExtension\n * } from 'mdast-util-to-markdown'\n * @import {FootnoteDefinition, FootnoteReference} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteReference')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteDefinition')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[^')\n  const exit = state.enter('footnoteReference')\n  const subexit = state.enter('reference')\n  value += tracker.move(\n    state.safe(state.associationId(node), {after: ']', before: value})\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteCallString: enterFootnoteCallString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: enterFootnoteDefinition\n    },\n    exit: {\n      gfmFootnoteCallString: exitFootnoteCallString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: exitFootnoteDefinition\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown(options) {\n  // To do: next major: change default.\n  let firstLineBlank = false\n\n  if (options && options.firstLineBlank) {\n    firstLineBlank = true\n  }\n\n  return {\n    handlers: {footnoteDefinition, footnoteReference},\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['label', 'phrasing', 'reference']}]\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, state, info) {\n    const tracker = state.createTracker(info)\n    let value = tracker.move('[^')\n    const exit = state.enter('footnoteDefinition')\n    const subexit = state.enter('label')\n    value += tracker.move(\n      state.safe(state.associationId(node), {before: value, after: ']'})\n    )\n    subexit()\n\n    value += tracker.move(']:')\n\n    if (node.children && node.children.length > 0) {\n      tracker.shift(4)\n\n      value += tracker.move(\n        (firstLineBlank ? '\\n' : ' ') +\n          state.indentLines(\n            state.containerFlow(node, tracker.current()),\n            firstLineBlank ? mapAll : mapExceptFirst\n          )\n      )\n    }\n\n    exit()\n\n    return value\n  }\n}\n\n/** @type {Map} */\nfunction mapExceptFirst(line, index, blank) {\n  return index === 0 ? line : mapAll(line, index, blank)\n}\n\n/** @type {Map} */\nfunction mapAll(line, index, blank) {\n  return (blank ? '' : '    ') + line\n}\n", "/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n", "// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesn‚Äôt place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its ‚Äúvisible‚Äù size;\n *   note that what is and isn‚Äôt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['‰∏≠Êñá', 'Charlie'],\n *     ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | ‰∏≠Êñá | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë© | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['‰∏≠Êñá', 'Charlie'],\n *       ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | ‰∏≠Êñá  | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë©    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don‚Äôt align delimiters, but otherwise we‚Äôd\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don‚Äôt add the opening space if we‚Äôre not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n", "/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').TableRow} TableRow\n *\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').State} State\n * @typedef {import('mdast-util-to-markdown').Info} Info\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells (default:\n *   `true`).\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters (default: `true`).\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells (optional).\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownTable} from 'markdown-table'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\n */\nexport function gfmTableFromMarkdown() {\n  return {\n    enter: {\n      table: enterTable,\n      tableData: enterCell,\n      tableHeader: enterCell,\n      tableRow: enterRow\n    },\n    exit: {\n      codeText: exitCodeText,\n      table: exitTable,\n      tableData: exit,\n      tableHeader: exit,\n      tableRow: exit\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  const align = token._align\n  assert(align, 'expected `_align` on table')\n  this.enter(\n    {\n      type: 'table',\n      align: align.map(function (d) {\n        return d === 'none' ? null : d\n      }),\n      children: []\n    },\n    token\n  )\n  this.data.inTable = true\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.data.inTable = undefined\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.data.inTable) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'inlineCode')\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don‚Äôt (but can‚Äôt escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      inlineCode: inlineCodeWithTable,\n      table: handleTable,\n      tableCell: handleTableCell,\n      tableRow: handleTableRow\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, state, info) {\n    return serializeData(handleTableAsData(node, state, info), node.align)\n  }\n\n  /**\n   * This function isn‚Äôt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, state, info) {\n    const row = handleTableRowAsData(node, state, info)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, state, info) {\n    const exit = state.enter('tableCell')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...info,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = state.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableRowAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = state.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(children[index], node, state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, state) {\n    let value = defaultHandlers.inlineCode(node, parent, state)\n\n    if (state.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n", "/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // We‚Äôre always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n", "/**\n * @import {Extension as FromMarkdownExtension} from 'mdast-util-from-markdown'\n * @import {Options} from 'mdast-util-gfm'\n * @import {Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown(),\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown(),\n      gfmFootnoteToMarkdown(options),\n      gfmStrikethroughToMarkdown(),\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown()\n    ]\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAe,SAAR,mBAAoC,QAAQ;AAClD,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,IAAI,UAAU,mBAAmB;AAAA,EACxC;AAIA,SAAO,OACL,QAAQ,uBAAuB,MAAM,EACrC,QAAQ,MAAM,OAAO;AACxB;;;ACmEO,SAAS,eAAe,MAAM,MAAM,SAAS;AAClD,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,UAAU,QAAQ,SAAS,UAAU,CAAC,CAAC;AAC7C,QAAM,QAAQ,QAAQ,IAAI;AAC1B,MAAI,YAAY;AAEhB,SAAO,EAAE,YAAY,MAAM,QAAQ;AACjC,iBAAa,MAAM,QAAQ,OAAO;AAAA,EACpC;AAGA,WAAS,QAAQ,MAAM,SAAS;AAC9B,QAAI,QAAQ;AAEZ,QAAI;AAEJ,WAAO,EAAE,QAAQ,QAAQ,QAAQ;AAC/B,YAAM,SAAS,QAAQ,KAAK;AAE5B,YAAM,WAAW,cAAc,YAAY,WAAW;AAEtD,UACE;AAAA,QACE;AAAA,QACA,WAAW,SAAS,QAAQ,MAAM,IAAI;AAAA,QACtC;AAAA,MACF,GACA;AACA;AAAA,MACF;AAEA,oBAAc;AAAA,IAChB;AAEA,QAAI,aAAa;AACf,aAAO,QAAQ,MAAM,OAAO;AAAA,IAC9B;AAAA,EACF;AAYA,WAAS,QAAQ,MAAM,SAAS;AAC9B,UAAM,SAAS,QAAQ,QAAQ,SAAS,CAAC;AACzC,UAAM,OAAO,MAAM,SAAS,EAAE,CAAC;AAC/B,UAAMA,WAAU,MAAM,SAAS,EAAE,CAAC;AAClC,QAAI,QAAQ;AAEZ,UAAM,WAAW,OAAO;AACxB,UAAM,QAAQ,SAAS,QAAQ,IAAI;AACnC,QAAI,SAAS;AAEb,QAAI,QAAQ,CAAC;AAEb,SAAK,YAAY;AAEjB,QAAI,QAAQ,KAAK,KAAK,KAAK,KAAK;AAEhC,WAAO,OAAO;AACZ,YAAM,WAAW,MAAM;AAEvB,YAAM,cAAc;AAAA,QAClB,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA,QACb,OAAO,CAAC,GAAG,SAAS,IAAI;AAAA,MAC1B;AACA,UAAI,QAAQA,SAAQ,GAAG,OAAO,WAAW;AAEzC,UAAI,OAAO,UAAU,UAAU;AAC7B,gBAAQ,MAAM,SAAS,IAAI,EAAC,MAAM,QAAQ,MAAK,IAAI;AAAA,MACrD;AAGA,UAAI,UAAU,OAAO;AAInB,aAAK,YAAY,WAAW;AAAA,MAC9B,OAAO;AACL,YAAI,UAAU,UAAU;AACtB,gBAAM,KAAK;AAAA,YACT,MAAM;AAAA,YACN,OAAO,KAAK,MAAM,MAAM,OAAO,QAAQ;AAAA,UACzC,CAAC;AAAA,QACH;AAEA,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,KAAK,GAAG,KAAK;AAAA,QACrB,WAAW,OAAO;AAChB,gBAAM,KAAK,KAAK;AAAA,QAClB;AAEA,gBAAQ,WAAW,MAAM,CAAC,EAAE;AAC5B,iBAAS;AAAA,MACX;AAEA,UAAI,CAAC,KAAK,QAAQ;AAChB;AAAA,MACF;AAEA,cAAQ,KAAK,KAAK,KAAK,KAAK;AAAA,IAC9B;AAEA,QAAI,QAAQ;AACV,UAAI,QAAQ,KAAK,MAAM,QAAQ;AAC7B,cAAM,KAAK,EAAC,MAAM,QAAQ,OAAO,KAAK,MAAM,MAAM,KAAK,EAAC,CAAC;AAAA,MAC3D;AAEA,aAAO,SAAS,OAAO,OAAO,GAAG,GAAG,KAAK;AAAA,IAC3C,OAAO;AACL,cAAQ,CAAC,IAAI;AAAA,IACf;AAEA,WAAO,QAAQ,MAAM;AAAA,EACvB;AACF;AAUA,SAAS,QAAQ,aAAa;AAE5B,QAAM,SAAS,CAAC;AAEhB,MAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAC/B,UAAM,IAAI,UAAU,mDAAmD;AAAA,EACzE;AAIA,QAAM,OACJ,CAAC,YAAY,CAAC,KAAK,MAAM,QAAQ,YAAY,CAAC,CAAC,IAC3C,cACA,CAAC,WAAW;AAElB,MAAI,QAAQ;AAEZ,SAAO,EAAE,QAAQ,KAAK,QAAQ;AAC5B,UAAM,QAAQ,KAAK,KAAK;AACxB,WAAO,KAAK,CAAC,aAAa,MAAM,CAAC,CAAC,GAAG,WAAW,MAAM,CAAC,CAAC,CAAC,CAAC;AAAA,EAC5D;AAEA,SAAO;AACT;AAUA,SAAS,aAAa,MAAM;AAC1B,SAAO,OAAO,SAAS,WAAW,IAAI,OAAO,mBAAO,IAAI,GAAG,GAAG,IAAI;AACpE;AAUA,SAAS,WAAWA,UAAS;AAC3B,SAAO,OAAOA,aAAY,aACtBA,WACA,WAAY;AACV,WAAOA;AAAA,EACT;AACN;;;ACvPA,IAAM,cAAc;AAEpB,IAAM,iBAAiB,CAAC,YAAY,QAAQ,SAAS,OAAO;AASrD,SAAS,iCAAiC;AAC/C,SAAO;AAAA,IACL,YAAY,CAAC,4BAA4B;AAAA,IACzC,OAAO;AAAA,MACL,iBAAiB;AAAA,MACjB,sBAAsB;AAAA,MACtB,qBAAqB;AAAA,MACrB,oBAAoB;AAAA,IACtB;AAAA,IACA,MAAM;AAAA,MACJ,iBAAiB;AAAA,MACjB,sBAAsB;AAAA,MACtB,qBAAqB;AAAA,MACrB,oBAAoB;AAAA,IACtB;AAAA,EACF;AACF;AASO,SAAS,+BAA+B;AAC7C,SAAO;AAAA,IACL,QAAQ;AAAA,MACN;AAAA,QACE,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,QACE,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,QACE,WAAW;AAAA,QACX,QAAQ;AAAA,QACR,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAMA,SAAS,qBAAqB,OAAO;AACnC,OAAK,MAAM,EAAC,MAAM,QAAQ,OAAO,MAAM,KAAK,IAAI,UAAU,CAAC,EAAC,GAAG,KAAK;AACtE;AAMA,SAAS,0BAA0B,OAAO;AACxC,OAAK,OAAO,MAAM,iBAAiB,KAAK,MAAM,KAAK;AACrD;AAMA,SAAS,wBAAwB,OAAO;AACtC,OAAK,OAAO,KAAK,iBAAiB,KAAK,MAAM,KAAK;AACpD;AAMA,SAAS,uBAAuB,OAAO;AACrC,OAAK,OAAO,KAAK,KAAK,KAAK,MAAM,KAAK;AACtC,QAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,KAAO,KAAK,SAAS,MAAM;AAC3B,OAAK,MAAM,YAAY,KAAK,eAAe,KAAK;AAClD;AAMA,SAAS,yBAAyB,OAAO;AACvC,OAAK,OAAO,KAAK,cAAc,KAAK,MAAM,KAAK;AACjD;AAMA,SAAS,oBAAoB,OAAO;AAClC,OAAK,KAAK,KAAK;AACjB;AAGA,SAAS,6BAA6B,MAAM;AAC1C;AAAA,IACE;AAAA,IACA;AAAA,MACE,CAAC,mDAAmD,OAAO;AAAA,MAC3D,CAAC,WAAC,gEAAsD,IAAE,GAAE,SAAS;AAAA,IACvE;AAAA,IACA,EAAC,QAAQ,CAAC,QAAQ,eAAe,EAAC;AAAA,EACpC;AACF;AAYA,SAAS,QAAQ,GAAG,UAAU,QAAQ,MAAM,OAAO;AACjD,MAAI,SAAS;AAGb,MAAI,CAAC,SAAS,KAAK,GAAG;AACpB,WAAO;AAAA,EACT;AAGA,MAAI,MAAM,KAAK,QAAQ,GAAG;AACxB,aAAS,WAAW;AACpB,eAAW;AACX,aAAS;AAAA,EACX;AAEA,MAAI,CAAC,gBAAgB,MAAM,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,SAAS,SAAS,IAAI;AAEpC,MAAI,CAAC,MAAM,CAAC,EAAG,QAAO;AAGtB,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK,SAAS,WAAW,MAAM,CAAC;AAAA,IAChC,UAAU,CAAC,EAAC,MAAM,QAAQ,OAAO,WAAW,MAAM,CAAC,EAAC,CAAC;AAAA,EACvD;AAEA,MAAI,MAAM,CAAC,GAAG;AACZ,WAAO,CAAC,QAAQ,EAAC,MAAM,QAAQ,OAAO,MAAM,CAAC,EAAC,CAAC;AAAA,EACjD;AAEA,SAAO;AACT;AAUA,SAAS,UAAU,GAAG,OAAO,OAAO,OAAO;AACzC;AAAA;AAAA,IAEE,CAAC,SAAS,OAAO,IAAI;AAAA,IAErB,UAAU,KAAK,KAAK;AAAA,IACpB;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC/B,UAAU,CAAC,EAAC,MAAM,QAAQ,OAAO,QAAQ,MAAM,MAAK,CAAC;AAAA,EACvD;AACF;AAMA,SAAS,gBAAgB,QAAQ;AAC/B,QAAM,QAAQ,OAAO,MAAM,GAAG;AAE9B,MACE,MAAM,SAAS,KACd,MAAM,MAAM,SAAS,CAAC,MACpB,IAAI,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,KAC/B,CAAC,aAAa,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,MAC7C,MAAM,MAAM,SAAS,CAAC,MACpB,IAAI,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,KAC/B,CAAC,aAAa,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,IAC9C;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAMA,SAAS,SAAS,KAAK;AACrB,QAAM,YAAY,sBAAsB,KAAK,GAAG;AAEhD,MAAI,CAAC,WAAW;AACd,WAAO,CAAC,KAAK,MAAS;AAAA,EACxB;AAEA,QAAM,IAAI,MAAM,GAAG,UAAU,KAAK;AAElC,MAAI,QAAQ,UAAU,CAAC;AACvB,MAAI,oBAAoB,MAAM,QAAQ,GAAG;AACzC,QAAM,gBAAgB,OAAO,KAAK,GAAG;AACrC,MAAI,gBAAgB,OAAO,KAAK,GAAG;AAEnC,SAAO,sBAAsB,MAAM,gBAAgB,eAAe;AAChE,WAAO,MAAM,MAAM,GAAG,oBAAoB,CAAC;AAC3C,YAAQ,MAAM,MAAM,oBAAoB,CAAC;AACzC,wBAAoB,MAAM,QAAQ,GAAG;AACrC;AAAA,EACF;AAEA,SAAO,CAAC,KAAK,KAAK;AACpB;AAOA,SAAS,SAAS,OAAO,OAAO;AAC9B,QAAM,OAAO,MAAM,MAAM,WAAW,MAAM,QAAQ,CAAC;AAEnD,UACG,MAAM,UAAU,KACf,kBAAkB,IAAI,KACtB,mBAAmB,IAAI;AAAA,GAExB,CAAC,SAAS,SAAS;AAExB;;;ACrQA,kBAAkB,OAAO;AAMzB,SAAS,0BAA0B;AACjC,OAAK,OAAO;AACd;AAMA,SAAS,kBAAkB,OAAO;AAChC,OAAK,MAAM,EAAC,MAAM,qBAAqB,YAAY,IAAI,OAAO,GAAE,GAAG,KAAK;AAC1E;AAMA,SAAS,qCAAqC;AAC5C,OAAK,OAAO;AACd;AAMA,SAAS,wBAAwB,OAAO;AACtC,OAAK;AAAA,IACH,EAAC,MAAM,sBAAsB,YAAY,IAAI,OAAO,IAAI,UAAU,CAAC,EAAC;AAAA,IACpE;AAAA,EACF;AACF;AAMA,SAAS,uBAAuB,OAAO;AACrC,QAAM,QAAQ,KAAK,OAAO;AAC1B,QAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,KAAO,KAAK,SAAS,mBAAmB;AACxC,OAAK,aAAa;AAAA,IAChB,KAAK,eAAe,KAAK;AAAA,EAC3B,EAAE,YAAY;AACd,OAAK,QAAQ;AACf;AAMA,SAAS,iBAAiB,OAAO;AAC/B,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,kCAAkC,OAAO;AAChD,QAAM,QAAQ,KAAK,OAAO;AAC1B,QAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,KAAO,KAAK,SAAS,oBAAoB;AACzC,OAAK,aAAa;AAAA,IAChB,KAAK,eAAe,KAAK;AAAA,EAC3B,EAAE,YAAY;AACd,OAAK,QAAQ;AACf;AAMA,SAAS,uBAAuB,OAAO;AACrC,OAAK,KAAK,KAAK;AACjB;AAGA,SAAS,wBAAwB;AAC/B,SAAO;AACT;AAMA,SAAS,kBAAkB,MAAM,GAAG,OAAO,MAAM;AAC/C,QAAM,UAAU,MAAM,cAAc,IAAI;AACxC,MAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,QAAMC,QAAO,MAAM,MAAM,mBAAmB;AAC5C,QAAM,UAAU,MAAM,MAAM,WAAW;AACvC,WAAS,QAAQ;AAAA,IACf,MAAM,KAAK,MAAM,cAAc,IAAI,GAAG,EAAC,OAAO,KAAK,QAAQ,MAAK,CAAC;AAAA,EACnE;AACA,UAAQ;AACR,EAAAA,MAAK;AACL,WAAS,QAAQ,KAAK,GAAG;AACzB,SAAO;AACT;AASO,SAAS,0BAA0B;AACxC,SAAO;AAAA,IACL,OAAO;AAAA,MACL,uBAAuB;AAAA,MACvB,iBAAiB;AAAA,MACjB,kCAAkC;AAAA,MAClC,uBAAuB;AAAA,IACzB;AAAA,IACA,MAAM;AAAA,MACJ,uBAAuB;AAAA,MACvB,iBAAiB;AAAA,MACjB,kCAAkC;AAAA,MAClC,uBAAuB;AAAA,IACzB;AAAA,EACF;AACF;AAWO,SAAS,sBAAsB,SAAS;AAE7C,MAAI,iBAAiB;AAErB,MAAI,WAAW,QAAQ,gBAAgB;AACrC,qBAAiB;AAAA,EACnB;AAEA,SAAO;AAAA,IACL,UAAU,EAAC,oBAAoB,kBAAiB;AAAA;AAAA,IAEhD,QAAQ,CAAC,EAAC,WAAW,KAAK,aAAa,CAAC,SAAS,YAAY,WAAW,EAAC,CAAC;AAAA,EAC5E;AAMA,WAAS,mBAAmB,MAAM,GAAG,OAAO,MAAM;AAChD,UAAM,UAAU,MAAM,cAAc,IAAI;AACxC,QAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,UAAMA,QAAO,MAAM,MAAM,oBAAoB;AAC7C,UAAM,UAAU,MAAM,MAAM,OAAO;AACnC,aAAS,QAAQ;AAAA,MACf,MAAM,KAAK,MAAM,cAAc,IAAI,GAAG,EAAC,QAAQ,OAAO,OAAO,IAAG,CAAC;AAAA,IACnE;AACA,YAAQ;AAER,aAAS,QAAQ,KAAK,IAAI;AAE1B,QAAI,KAAK,YAAY,KAAK,SAAS,SAAS,GAAG;AAC7C,cAAQ,MAAM,CAAC;AAEf,eAAS,QAAQ;AAAA,SACd,iBAAiB,OAAO,OACvB,MAAM;AAAA,UACJ,MAAM,cAAc,MAAM,QAAQ,QAAQ,CAAC;AAAA,UAC3C,iBAAiB,SAAS;AAAA,QAC5B;AAAA,MACJ;AAAA,IACF;AAEA,IAAAA,MAAK;AAEL,WAAO;AAAA,EACT;AACF;AAGA,SAAS,eAAe,MAAM,OAAO,OAAO;AAC1C,SAAO,UAAU,IAAI,OAAO,OAAO,MAAM,OAAO,KAAK;AACvD;AAGA,SAAS,OAAO,MAAM,OAAO,OAAO;AAClC,UAAQ,QAAQ,KAAK,UAAU;AACjC;;;AC7LA,IAAM,iCAAiC;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,aAAa,OAAO;AASb,SAAS,+BAA+B;AAC7C,SAAO;AAAA,IACL,gBAAgB,CAAC,QAAQ;AAAA,IACzB,OAAO,EAAC,eAAe,mBAAkB;AAAA,IACzC,MAAM,EAAC,eAAe,kBAAiB;AAAA,EACzC;AACF;AASO,SAAS,6BAA6B;AAC3C,SAAO;AAAA,IACL,QAAQ;AAAA,MACN;AAAA,QACE,WAAW;AAAA,QACX,aAAa;AAAA,QACb,gBAAgB;AAAA,MAClB;AAAA,IACF;AAAA,IACA,UAAU,EAAC,QAAQ,aAAY;AAAA,EACjC;AACF;AAMA,SAAS,mBAAmB,OAAO;AACjC,OAAK,MAAM,EAAC,MAAM,UAAU,UAAU,CAAC,EAAC,GAAG,KAAK;AAClD;AAMA,SAAS,kBAAkB,OAAO;AAChC,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,aAAa,MAAM,GAAG,OAAO,MAAM;AAC1C,QAAM,UAAU,MAAM,cAAc,IAAI;AACxC,QAAMC,QAAO,MAAM,MAAM,eAAe;AACxC,MAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,WAAS,MAAM,kBAAkB,MAAM;AAAA,IACrC,GAAG,QAAQ,QAAQ;AAAA,IACnB,QAAQ;AAAA,IACR,OAAO;AAAA,EACT,CAAC;AACD,WAAS,QAAQ,KAAK,IAAI;AAC1B,EAAAA,MAAK;AACL,SAAO;AACT;AAGA,SAAS,aAAa;AACpB,SAAO;AACT;;;ACgDA,SAAS,oBAAoB,OAAO;AAClC,SAAO,MAAM;AACf;AAcO,SAAS,cAAc,OAAO,SAAS;AAC5C,QAAM,WAAW,WAAW,CAAC;AAE7B,QAAM,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO;AAC5C,QAAM,eAAe,SAAS,gBAAgB;AAE9C,QAAM,aAAa,CAAC;AAEpB,QAAM,aAAa,CAAC;AAEpB,QAAM,aAAa,CAAC;AAEpB,QAAM,sBAAsB,CAAC;AAC7B,MAAI,kBAAkB;AACtB,MAAI,WAAW;AAIf,SAAO,EAAE,WAAW,MAAM,QAAQ;AAEhC,UAAMC,OAAM,CAAC;AAEb,UAAMC,SAAQ,CAAC;AACf,QAAIC,eAAc;AAElB,QAAI,MAAM,QAAQ,EAAE,SAAS,iBAAiB;AAC5C,wBAAkB,MAAM,QAAQ,EAAE;AAAA,IACpC;AAEA,WAAO,EAAEA,eAAc,MAAM,QAAQ,EAAE,QAAQ;AAC7C,YAAM,OAAO,UAAU,MAAM,QAAQ,EAAEA,YAAW,CAAC;AAEnD,UAAI,SAAS,oBAAoB,OAAO;AACtC,cAAM,OAAO,aAAa,IAAI;AAC9B,QAAAD,OAAMC,YAAW,IAAI;AAErB,YACE,oBAAoBA,YAAW,MAAM,UACrC,OAAO,oBAAoBA,YAAW,GACtC;AACA,8BAAoBA,YAAW,IAAI;AAAA,QACrC;AAAA,MACF;AAEA,MAAAF,KAAI,KAAK,IAAI;AAAA,IACf;AAEA,eAAW,QAAQ,IAAIA;AACvB,eAAW,QAAQ,IAAIC;AAAA,EACzB;AAGA,MAAI,cAAc;AAElB,MAAI,OAAO,UAAU,YAAY,YAAY,OAAO;AAClD,WAAO,EAAE,cAAc,iBAAiB;AACtC,iBAAW,WAAW,IAAI,YAAY,MAAM,WAAW,CAAC;AAAA,IAC1D;AAAA,EACF,OAAO;AACL,UAAM,OAAO,YAAY,KAAK;AAE9B,WAAO,EAAE,cAAc,iBAAiB;AACtC,iBAAW,WAAW,IAAI;AAAA,IAC5B;AAAA,EACF;AAGA,gBAAc;AAEd,QAAM,MAAM,CAAC;AAEb,QAAM,QAAQ,CAAC;AAEf,SAAO,EAAE,cAAc,iBAAiB;AACtC,UAAM,OAAO,WAAW,WAAW;AACnC,QAAI,SAAS;AACb,QAAI,QAAQ;AAEZ,QAAI,SAAS,IAAc;AACzB,eAAS;AACT,cAAQ;AAAA,IACV,WAAW,SAAS,KAAe;AACjC,eAAS;AAAA,IACX,WAAW,SAAS,KAAe;AACjC,cAAQ;AAAA,IACV;AAGA,QAAI,OACF,SAAS,oBAAoB,QACzB,IACA,KAAK;AAAA,MACH;AAAA,MACA,oBAAoB,WAAW,IAAI,OAAO,SAAS,MAAM;AAAA,IAC3D;AAEN,UAAM,OAAO,SAAS,IAAI,OAAO,IAAI,IAAI;AAEzC,QAAI,SAAS,oBAAoB,OAAO;AACtC,aAAO,OAAO,SAAS,OAAO,MAAM;AAEpC,UAAI,OAAO,oBAAoB,WAAW,GAAG;AAC3C,4BAAoB,WAAW,IAAI;AAAA,MACrC;AAEA,YAAM,WAAW,IAAI;AAAA,IACvB;AAEA,QAAI,WAAW,IAAI;AAAA,EACrB;AAGA,aAAW,OAAO,GAAG,GAAG,GAAG;AAC3B,aAAW,OAAO,GAAG,GAAG,KAAK;AAE7B,aAAW;AAEX,QAAM,QAAQ,CAAC;AAEf,SAAO,EAAE,WAAW,WAAW,QAAQ;AACrC,UAAMD,OAAM,WAAW,QAAQ;AAC/B,UAAMC,SAAQ,WAAW,QAAQ;AACjC,kBAAc;AAEd,UAAM,OAAO,CAAC;AAEd,WAAO,EAAE,cAAc,iBAAiB;AACtC,YAAM,OAAOD,KAAI,WAAW,KAAK;AACjC,UAAI,SAAS;AACb,UAAI,QAAQ;AAEZ,UAAI,SAAS,oBAAoB,OAAO;AACtC,cAAM,OACJ,oBAAoB,WAAW,KAAKC,OAAM,WAAW,KAAK;AAC5D,cAAM,OAAO,WAAW,WAAW;AAEnC,YAAI,SAAS,KAAe;AAC1B,mBAAS,IAAI,OAAO,IAAI;AAAA,QAC1B,WAAW,SAAS,IAAc;AAChC,cAAI,OAAO,GAAG;AACZ,qBAAS,IAAI,OAAO,OAAO,IAAI,GAAG;AAClC,oBAAQ,IAAI,OAAO,OAAO,IAAI,GAAG;AAAA,UACnC,OAAO;AACL,qBAAS,IAAI,OAAO,OAAO,CAAC;AAC5B,oBAAQ;AAAA,UACV;AAAA,QACF,OAAO;AACL,kBAAQ,IAAI,OAAO,IAAI;AAAA,QACzB;AAAA,MACF;AAEA,UAAI,SAAS,mBAAmB,SAAS,CAAC,aAAa;AACrD,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UACE,SAAS,YAAY;AAAA;AAAA,MAGrB,EAAE,SAAS,oBAAoB,SAAS,SAAS,QAChD,SAAS,mBAAmB,SAAS,cACtC;AACA,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UAAI,SAAS,oBAAoB,OAAO;AACtC,aAAK,KAAK,MAAM;AAAA,MAClB;AAEA,WAAK,KAAK,IAAI;AAEd,UAAI,SAAS,oBAAoB,OAAO;AACtC,aAAK,KAAK,KAAK;AAAA,MACjB;AAEA,UAAI,SAAS,YAAY,OAAO;AAC9B,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UACE,SAAS,iBAAiB,SAC1B,gBAAgB,kBAAkB,GAClC;AACA,aAAK,KAAK,GAAG;AAAA,MACf;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,SAAS,iBAAiB,QACtB,KAAK,KAAK,EAAE,EAAE,QAAQ,OAAO,EAAE,IAC/B,KAAK,KAAK,EAAE;AAAA,IAClB;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAQA,SAAS,UAAU,OAAO;AACxB,SAAO,UAAU,QAAQ,UAAU,SAAY,KAAK,OAAO,KAAK;AAClE;AAQA,SAAS,YAAY,OAAO;AAC1B,QAAM,OAAO,OAAO,UAAU,WAAW,MAAM,YAAY,CAAC,IAAI;AAEhE,SAAO,SAAS,MAAgB,SAAS,KACrC,KACA,SAAS,MAAgB,SAAS,MAChC,MACA,SAAS,MAAgB,SAAS,MAChC,MACA;AACV;;;AC9VO,SAAS,uBAAuB;AACrC,SAAO;AAAA,IACL,OAAO;AAAA,MACL,OAAO;AAAA,MACP,WAAW;AAAA,MACX,aAAa;AAAA,MACb,UAAU;AAAA,IACZ;AAAA,IACA,MAAM;AAAA,MACJ,UAAU;AAAA,MACV,OAAO;AAAA,MACP,WAAW;AAAA,MACX,aAAa;AAAA,MACb,UAAU;AAAA,IACZ;AAAA,EACF;AACF;AAMA,SAAS,WAAW,OAAO;AACzB,QAAM,QAAQ,MAAM;AACpB,KAAO,OAAO,4BAA4B;AAC1C,OAAK;AAAA,IACH;AAAA,MACE,MAAM;AAAA,MACN,OAAO,MAAM,IAAI,SAAU,GAAG;AAC5B,eAAO,MAAM,SAAS,OAAO;AAAA,MAC/B,CAAC;AAAA,MACD,UAAU,CAAC;AAAA,IACb;AAAA,IACA;AAAA,EACF;AACA,OAAK,KAAK,UAAU;AACtB;AAMA,SAAS,UAAU,OAAO;AACxB,OAAK,KAAK,KAAK;AACf,OAAK,KAAK,UAAU;AACtB;AAMA,SAAS,SAAS,OAAO;AACvB,OAAK,MAAM,EAAC,MAAM,YAAY,UAAU,CAAC,EAAC,GAAG,KAAK;AACpD;AAMA,SAAS,KAAK,OAAO;AACnB,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,UAAU,OAAO;AACxB,OAAK,MAAM,EAAC,MAAM,aAAa,UAAU,CAAC,EAAC,GAAG,KAAK;AACrD;AAQA,SAAS,aAAa,OAAO;AAC3B,MAAI,QAAQ,KAAK,OAAO;AAExB,MAAI,KAAK,KAAK,SAAS;AACrB,YAAQ,MAAM,QAAQ,cAAc,OAAO;AAAA,EAC7C;AAEA,QAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,KAAO,KAAK,SAAS,YAAY;AACjC,OAAK,QAAQ;AACb,OAAK,KAAK,KAAK;AACjB;AAOA,SAAS,QAAQ,IAAI,IAAI;AAEvB,SAAO,OAAO,MAAM,KAAK;AAC3B;AAWO,SAAS,mBAAmB,SAAS;AAC1C,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,UAAU,SAAS;AACzB,QAAM,kBAAkB,SAAS;AACjC,QAAM,eAAe,SAAS;AAC9B,QAAM,SAAS,UAAU,MAAM;AAE/B,SAAO;AAAA,IACL,QAAQ;AAAA,MACN,EAAC,WAAW,MAAM,aAAa,YAAW;AAAA,MAC1C,EAAC,WAAW,MAAM,aAAa,YAAW;AAAA;AAAA;AAAA,MAG1C,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,SAAS;AAAA;AAAA,MAEhD,EAAC,WAAW,KAAK,aAAa,YAAW;AAAA;AAAA;AAAA,MAGzC,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,IAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAM1C,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,QAAO;AAAA,IAChD;AAAA,IACA,UAAU;AAAA,MACR,YAAY;AAAA,MACZ,OAAO;AAAA,MACP,WAAW;AAAA,MACX,UAAU;AAAA,IACZ;AAAA,EACF;AAMA,WAAS,YAAY,MAAM,GAAG,OAAO,MAAM;AACzC,WAAO,cAAc,kBAAkB,MAAM,OAAO,IAAI,GAAG,KAAK,KAAK;AAAA,EACvE;AAUA,WAAS,eAAe,MAAM,GAAG,OAAO,MAAM;AAC5C,UAAM,MAAM,qBAAqB,MAAM,OAAO,IAAI;AAClD,UAAM,QAAQ,cAAc,CAAC,GAAG,CAAC;AAEjC,WAAO,MAAM,MAAM,GAAG,MAAM,QAAQ,IAAI,CAAC;AAAA,EAC3C;AAMA,WAAS,gBAAgB,MAAM,GAAG,OAAO,MAAM;AAC7C,UAAME,QAAO,MAAM,MAAM,WAAW;AACpC,UAAM,UAAU,MAAM,MAAM,UAAU;AACtC,UAAM,QAAQ,MAAM,kBAAkB,MAAM;AAAA,MAC1C,GAAG;AAAA,MACH,QAAQ;AAAA,MACR,OAAO;AAAA,IACT,CAAC;AACD,YAAQ;AACR,IAAAA,MAAK;AACL,WAAO;AAAA,EACT;AAMA,WAAS,cAAc,QAAQ,OAAO;AACpC,WAAO,cAAc,QAAQ;AAAA,MAC3B;AAAA;AAAA,MAEA;AAAA;AAAA,MAEA;AAAA;AAAA,MAEA;AAAA,IACF,CAAC;AAAA,EACH;AAOA,WAAS,kBAAkB,MAAM,OAAO,MAAM;AAC5C,UAAM,WAAW,KAAK;AACtB,QAAI,QAAQ;AAEZ,UAAM,SAAS,CAAC;AAChB,UAAM,UAAU,MAAM,MAAM,OAAO;AAEnC,WAAO,EAAE,QAAQ,SAAS,QAAQ;AAChC,aAAO,KAAK,IAAI,qBAAqB,SAAS,KAAK,GAAG,OAAO,IAAI;AAAA,IACnE;AAEA,YAAQ;AAER,WAAO;AAAA,EACT;AAOA,WAAS,qBAAqB,MAAM,OAAO,MAAM;AAC/C,UAAM,WAAW,KAAK;AACtB,QAAI,QAAQ;AAEZ,UAAM,SAAS,CAAC;AAChB,UAAM,UAAU,MAAM,MAAM,UAAU;AAEtC,WAAO,EAAE,QAAQ,SAAS,QAAQ;AAIhC,aAAO,KAAK,IAAI,gBAAgB,SAAS,KAAK,GAAG,MAAM,OAAO,IAAI;AAAA,IACpE;AAEA,YAAQ;AAER,WAAO;AAAA,EACT;AAMA,WAAS,oBAAoB,MAAM,QAAQ,OAAO;AAChD,QAAI,QAAQ,OAAgB,WAAW,MAAM,QAAQ,KAAK;AAE1D,QAAI,MAAM,MAAM,SAAS,WAAW,GAAG;AACrC,cAAQ,MAAM,QAAQ,OAAO,MAAM;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AACF;;;ACvRO,SAAS,8BAA8B;AAC5C,SAAO;AAAA,IACL,MAAM;AAAA,MACJ,2BAA2B;AAAA,MAC3B,6BAA6B;AAAA,MAC7B,WAAW;AAAA,IACb;AAAA,EACF;AACF;AASO,SAAS,4BAA4B;AAC1C,SAAO;AAAA,IACL,QAAQ,CAAC,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,QAAO,CAAC;AAAA,IACxD,UAAU,EAAC,UAAU,yBAAwB;AAAA,EAC/C;AACF;AAMA,SAAS,UAAU,OAAO;AAExB,QAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,KAAO,KAAK,SAAS,UAAU;AAC/B,OAAK,UAAU,MAAM,SAAS;AAChC;AAMA,SAAS,8BAA8B,OAAO;AAC5C,QAAM,SAAS,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAE/C,MACE,UACA,OAAO,SAAS,cAChB,OAAO,OAAO,YAAY,WAC1B;AACA,UAAM,OAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,OAAO,KAAK,SAAS,WAAW;AAChC,UAAM,OAAO,KAAK,SAAS,CAAC;AAE5B,QAAI,QAAQ,KAAK,SAAS,QAAQ;AAChC,YAAM,WAAW,OAAO;AACxB,UAAI,QAAQ;AAEZ,UAAI;AAEJ,aAAO,EAAE,QAAQ,SAAS,QAAQ;AAChC,cAAM,UAAU,SAAS,KAAK;AAC9B,YAAI,QAAQ,SAAS,aAAa;AAChC,4BAAkB;AAClB;AAAA,QACF;AAAA,MACF;AAEA,UAAI,oBAAoB,MAAM;AAE5B,aAAK,QAAQ,KAAK,MAAM,MAAM,CAAC;AAE/B,YAAI,KAAK,MAAM,WAAW,GAAG;AAC3B,eAAK,SAAS,MAAM;AAAA,QACtB,WACE,KAAK,YACL,KAAK,YACL,OAAO,KAAK,SAAS,MAAM,WAAW,UACtC;AACA,eAAK,SAAS,MAAM;AACpB,eAAK,SAAS,MAAM;AACpB,eAAK,SAAS,QAAQ,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,KAAK;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,yBAAyB,MAAM,QAAQ,OAAO,MAAM;AAC3D,QAAM,OAAO,KAAK,SAAS,CAAC;AAC5B,QAAM,YACJ,OAAO,KAAK,YAAY,aAAa,QAAQ,KAAK,SAAS;AAC7D,QAAM,WAAW,OAAO,KAAK,UAAU,MAAM,OAAO;AACpD,QAAM,UAAU,MAAM,cAAc,IAAI;AAExC,MAAI,WAAW;AACb,YAAQ,KAAK,QAAQ;AAAA,EACvB;AAEA,MAAI,QAAQ,OAAgB,SAAS,MAAM,QAAQ,OAAO;AAAA,IACxD,GAAG;AAAA,IACH,GAAG,QAAQ,QAAQ;AAAA,EACrB,CAAC;AAED,MAAI,WAAW;AACb,YAAQ,MAAM,QAAQ,mCAAmC,KAAK;AAAA,EAChE;AAEA,SAAO;AAMP,WAAS,MAAM,IAAI;AACjB,WAAO,KAAK;AAAA,EACd;AACF;;;AC5GO,SAAS,kBAAkB;AAChC,SAAO;AAAA,IACL,+BAA+B;AAAA,IAC/B,wBAAwB;AAAA,IACxB,6BAA6B;AAAA,IAC7B,qBAAqB;AAAA,IACrB,4BAA4B;AAAA,EAC9B;AACF;AAYO,SAAS,cAAc,SAAS;AACrC,SAAO;AAAA,IACL,YAAY;AAAA,MACV,6BAA6B;AAAA,MAC7B,sBAAsB,OAAO;AAAA,MAC7B,2BAA2B;AAAA,MAC3B,mBAAmB,OAAO;AAAA,MAC1B,0BAA0B;AAAA,IAC5B;AAAA,EACF;AACF;",
  "names": ["replace", "exit", "exit", "row", "sizes", "columnIndex", "exit"]
}
